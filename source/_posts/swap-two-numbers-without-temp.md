---
title: 如何不使用临时变量交换两个整形的值
layout: page
toc: true
tags: essays
comments: true
categories: algorithms
description: 当然不是整形应该也可以...
---

要交换两个整形的值,最容易想到的方法就是使用一个临时变量:

```C
void swap(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
```

如果不使用临时变量可以这样:
```C
void swap(int *a, int *b)
{
    *a = *a - *b;
    *b = *a + *b;
    *a = *b - *a;
}
```
如果对位运算熟悉的话可以:
```C
void swap(int *a, int *b)
{
    *a ^= *b;
    *b ^= *a;
    *a ^= *b;
}
```
那么还有别的方法吗?

### 奇技淫巧

还记得曾经学习c#的时候(一年前),知道了一种不使用临时变量交换两个数的方法:
```csharp
public static void Swap(ref int a, ref int b)
{
    a = b + (b = a) * 0;
}
```

我记得当时第一次看到这种解法感觉很奇妙(~~装逼~~),而且也测试了也的确可行.原理想想也很简单,就是利用了压栈的技巧.

之前给电脑装了windows+ubuntu双系统,现在也一直在使用ubuntu这个linux发行版学习C/C++.某次突然想到了交换变量这个古老的问题,所以想试试c但是或者c++的编译器能不能这样写,(~~以后如果面试被问到也可以**用~~)于是很简单的写了这么一个函数:
```C
void swap(int *a, int *p)
{
    *a = *b + (*b = *a) * 0;
}
```
我使用了gcc编译器,但是结果却是b没有被赋值为a.为什么呢?很明显出现这个结果表明＋后面的表达式乘以0被编译器直接优化掉了.．.之后我换回windows又使用visual studio 2015 + c#6.0测试了一下,发现也不行了,也就是说现在的C#编译器也进行了这个优化.

那么如何做到不加编译器开关让这个方法行之有效呢?很简单:
```C
void swap(int *a, int *b)
{
    *a = *a + *b - (*b = *a);
}
```

因为没有与0相乘,所以无论是gcc还是c#编译器编译器,都老老实实的编译了这一个表达式而没有优化掉后面的赋值表达式.所以这种写法可以得到理想的输出.

### 总结
~~虽然最后这种写法逼格很高,但是好像并没有什么卵用...我想现在的面试官都不会问交换两个变量这种简单的问题了吧...~~
